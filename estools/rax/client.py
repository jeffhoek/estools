# -*- coding: UTF-8 -*-
# (c)2013 Mik Kocikowski, MIT License (http://opensource.org/licenses/MIT)
# https://github.com/mkocikowski/estools

import argparse
import logging
import sys
import os
import json
import re
import contextlib
import itertools

import pyrax
pyrax.set_setting("identity_type", "rackspace")
pyrax.set_http_debug(False)

import estools.common.api
import estools.common.log
import estools.load.data

logger = logging.getLogger(__name__)
logging.getLogger('swiftclient').setLevel(logging.WARNING)

# DOCS:
# https://github.com/rackspace/pyrax/blob/master/docs/cloud_files.md

# alternately, you can have a file ~/.pyrax.cfg:
# [default]
# identity_type = rackspace
# region = DFW
# debug = True

RS_REGIONS = ['DFW', 'IAD']

RS_USERNAME = False
RS_PASSWORD = False
try:
    RS_USERNAME = os.environ['OS_USERNAME']
    RS_PASSWORD = os.environ['OS_PASSWORD']
except (KeyError, ) as exc:
    logger.debug("to connect to Cloudfiles, make sure OS_USERNAME and OS_PASSWORD environment variables are set")



def args_parser():

    parser = argparse.ArgumentParser(description="Rackspace cloudfiles client (%s)" % (estools.__version__, ), epilog="")
    parser.add_argument('path', type=str, nargs='?', action='store', help='REGION/container/filename')

    return parser


def set_credentials(username=RS_USERNAME, password=RS_PASSWORD):
    try:
        pyrax.set_credentials(username, password)
    except Exception as exc:
        logger.error(exc)
        raise ValueError("incorrect Rackspace credentials, make sure your OS_USERNAME and OS_PASSWORD environment vars are set correctly")
#     logger.debug(pyrax.identity.__dict__)


def get_connections(regions=RS_REGIONS):
    # TODO: conn caching / pooling
    connections = {r: pyrax.connect_to_cloudfiles(region=r) for r in regions}
    return connections


def _get_region_name(connection=None):
    return connection.connection.os_options['region_name']


def get_containers(connection=None):
    for container in connection.get_all_containers():
        yield container

def get_objects(container=None):
    for object in container.get_objects():
        yield object


def to_path(connection=None, container=None, object=None):
    path = "/".join((
        _get_region_name(connection),
        container.name,
        object.name,
    ))
    return path


def from_path(path=None):
    try:
        s = re.search(r"(?:.*://)?(?:/)?(.*$)", path).group(1).split("/")
        return (s[0].upper(), s[1], "/".join(s[2:]))
    except (IndexError, ) as exc:
        logger.warning(exc)
        raise ValueError("invalid 'path': %s" % path)


@contextlib.contextmanager
def fetch_object(region="", container="", name="", chunk_size=2**16):
    conn = get_connections()[region]
    meta, chunks = conn.fetch_object(container=container, obj=name, include_meta=True, chunk_size=chunk_size)
    yield (meta, chunks)
    for _ in chunks: pass # exhaust the chunksen: https://github.com/rackspace/pyrax/blob/master/docs/cloud_files.md#retrieving-downloading-stored-objects
    return


def chunks_to_lines(chunks):
    lines = (
        # joining up character iterators into strings. input here consists of
        # (key, iterator) tuples (from itertools.groupby), so make string from
        # [1].
        "".join(group[1]) for group in
            itertools.ifilter(
                # key for the filter is the key generated by groupby, which is
                # 'False' for groups consisting of newline - so these groups
                # get skipped
                lambda x: x[0],
                # makes alternating newline / not-newline groups of character
                # iterators, with groups consisting of newline keyed as 'False'
                itertools.groupby(
                    # makes an iterator of individual characters
                    itertools.chain.from_iterable(chunks),
                    # the key for groupby - if character is newline, create a
                    # new group
                    lambda x: x != "\n",
                )
            )
    )
    return lines


def get_lines(path=""):

    region, container, fn = from_path(path)
    with fetch_object(region=region, container=container, name=fn) as (meta, chunks):
        for line in chunks_to_lines(chunks):
            yield line




def main():

    estools.common.log.set_up_logging(level=logging.INFO)
    args = args_parser().parse_args()

    set_credentials()
    try:

        if args.path:
            for line in get_lines(args.path):
                print(line)

        else:
            for region, connection in get_connections().items():
                for container in get_containers(connection):
                    for object in get_objects(container):
                        print("cf://%s" % to_path(connection, container, object))


    except IOError as exc:
        logger.debug(exc)


if __name__ == "__main__":
    main()
    sys.exit(0)


